{"version":3,"file":"Water-BnddK7DH.js","sources":["../../src/shaders/water.vert?raw","../../src/shaders/water.frag?raw","../../src/objects/Water.js"],"sourcesContent":["export default \"precision highp float;\\n\\nuniform float uTime;\\n\\nuniform float uWavesAmplitude;\\nuniform float uWavesSpeed;\\nuniform float uWavesFrequency;\\nuniform float uWavesPersistence;\\nuniform float uWavesLacunarity;\\nuniform float uWavesIterations;\\n\\nuniform float time;\\nuniform int rippleCount;\\nuniform float uRippleHeight;\\nuniform float uRippleSpeed;\\nuniform float uRippleBase;\\nuniform float uRippleFade;\\n\\n\\nconst int MAX_RIPPLES = 10;\\n\\nuniform vec3 rippleCenters[MAX_RIPPLES];\\nuniform float rippleStartTimes[MAX_RIPPLES];\\n\\nuniform float radius;\\n\\nvarying vec3 vNormal;\\nvarying vec3 vWorldPosition;\\n\\nvarying float vElevation;\\n\\nuniform sampler2D uTexture;\\n\\n//\\tSimplex 2D Noise \\nvec4 permute(vec4 x) {\\n  return mod(((x * 34.0) + 1.0) * x, 289.0);\\n}\\nvec4 taylorInvSqrt(vec4 r) {\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\nvec3 permute(vec3 x) {\\n  return mod(((x * 34.0) + 1.0) * x, 289.0);\\n}\\n\\nfloat sphericalDistance(vec3 a, vec3 b) {\\n  float dotProd = dot(normalize(a), normalize(b));\\n  return acos(clamp(dotProd, -1.0, 1.0));\\n}\\n\\nfloat snoise(vec2 v) {\\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439, \\n                      -0.577350269189626, 0.024390243902439);\\n  vec2 i = floor(v + dot(v, C.yy));\\n  vec2 x0 = v - i + dot(i, C.xx);\\n  vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\\n  vec4 x12 = x0.xyxy + C.xxzz;\\n  x12.xy -= i1;\\n  i = mod(i, 289.0);\\n  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) \\n                 + i.x + vec3(0.0, i1.x, 1.0));\\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\\n  m = m*m;\\n  m = m*m;\\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\\n  vec3 h = abs(x) - 0.5;\\n  vec3 ox = floor(x + 0.5);\\n  vec3 a0 = x - ox;\\n  m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\\n  vec3 g;\\n  g.x  = a0.x * x0.x + h.x * x0.y;\\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\\n  return 130.0 * dot(m, g);\\n}\\n\\n// Elevation (fBM-style noise)\\nfloat getElevation(float x, float z) {\\n  vec2 pos = vec2(x, z);\\n  float elevation = 0.0;\\n  float amplitude = 1.0;\\n  float frequency = uWavesFrequency;\\n  \\n  for (float i = 0.0; i < 10.0; i++) {\\n    if (i >= uWavesIterations) break;\\n    elevation += amplitude * snoise(pos * frequency + uTime * uWavesSpeed);\\n    amplitude *= uWavesPersistence;\\n    frequency *= uWavesLacunarity;\\n  }\\n  elevation *= uWavesAmplitude;\\n  vElevation = elevation;\\n  return elevation;\\n}\\n\\nvoid main() {\\n  vec4 modelPosition = modelMatrix * vec4(position, 1.0);\\n\\n  vec3 sphereDir = normalize(modelPosition.xyz);\\n  float elevation = getElevation(sphereDir.x, sphereDir.z);\\n  modelPosition.xyz += sphereDir * elevation;\\n\\n  // Approximate normal\\n  float eps = 0.001;\\n  float dx = getElevation(sphereDir.x + eps, sphereDir.z) - elevation;\\n  float dz = getElevation(sphereDir.x, sphereDir.z + eps) - elevation;\\n  vec3 tangent = normalize(vec3(eps, dx, 0.0));\\n  vec3 bitangent = normalize(vec3(0.0, dz, eps));\\n  vec3 normal = normalize(cross(tangent, bitangent));\\n\\n  vNormal = normal;\\n  vWorldPosition = modelPosition.xyz;\\n\\n  float displacement = 0.0;\\n\\n  for (int i = 0; i < MAX_RIPPLES; i++) {\\n    if (i >= rippleCount) break;\\n    float age = time - rippleStartTimes[i];\\n    if (age < 0.0) continue;\\n\\n    float dist = sphericalDistance(position, rippleCenters[i]);\\n    float rippleRadius = age * uRippleSpeed;\\n    float delta = dist - rippleRadius;\\n\\n    if (abs(delta) < 0.35) {\\n      float baseWave = cos(delta * 20.0);\\n      float secondaryWave = 0.3 * cos(delta * uRippleBase);\\n      float wave = baseWave + secondaryWave;\\n\\n      float fade = smoothstep(0.35, 0.25, abs(delta));\\n      float ageFade = exp(-age * uRippleFade);\\n\\n      float noiseVal = snoise(vWorldPosition.xz * 5.0 + time * 2.0);\\n      noiseVal = (noiseVal + 1.0) / 2.0;\\n\\n      displacement += wave * fade * ageFade * uRippleHeight * (0.7 + 0.3 * noiseVal);\\n    }\\n  }\\n\\n  vec3 displacedPosition = normalize(position) * (radius + elevation + displacement);\\n\\n  modelPosition.xyz = displacedPosition;\\n  gl_Position = projectionMatrix * viewMatrix * modelPosition;\\n}\\n\"","export default \"precision highp float;\\n\\nuniform float uOpacity;\\n\\nuniform vec3 uTroughColor;\\nuniform vec3 uSurfaceColor;\\nuniform vec3 uPeakColor;\\n\\nuniform float uPeakThreshold;\\nuniform float uPeakTransition;\\nuniform float uTroughThreshold;\\nuniform float uTroughTransition;\\nuniform float uGroundAmplitude;\\n\\nuniform float uFresnelScale;\\nuniform float uFresnelPower;\\n\\nuniform sampler2D uTexture;\\nuniform samplerCube uEnvironmentMap;\\n\\nuniform vec2 uTexelSize;\\n\\nvarying vec3 vNormal;\\nvarying vec3 vWorldPosition;\\nvarying float vElevation;\\n\\nvoid main() {\\n    // --- Compute UV from world position on sphere\\n    vec3 sphereDir = normalize(vWorldPosition);\\n    float lat = asin(sphereDir.y);\\n    float lon = atan(sphereDir.z, sphereDir.x);\\n    vec2 uv = vec2(\\n        0.5 + lon / (2.0 * 3.14159265359),\\n        0.5 - lat / 3.14159265359\\n    );\\n\\n    // --- Reflection & Fresnel\\n    vec3 viewDir = normalize(vWorldPosition);\\n    vec3 reflectedDir = reflect(viewDir, vNormal);\\n    reflectedDir.x *= -1.0;\\n\\n    vec4 reflectionColor = textureCube(uEnvironmentMap, reflectedDir);\\n\\n    float fresnel = uFresnelScale * pow(1.0 - clamp(dot(viewDir, vNormal), 0.0, 1.0), uFresnelPower);\\n\\n    // --- Elevation-based gradient from procedural elevation\\n    float elevation = vElevation;\\n\\n    float troughFactor = smoothstep(\\n        uTroughThreshold - uTroughTransition,\\n        uTroughThreshold + uTroughTransition,\\n        elevation\\n    );\\n\\n    float peakFactor = smoothstep(\\n        uPeakThreshold - uPeakTransition,\\n        uPeakThreshold + uPeakTransition,\\n        elevation\\n    );\\n\\n    // --- Base water color\\n    vec3 baseColor = mix(uTroughColor, uSurfaceColor, troughFactor);\\n    baseColor = mix(baseColor, uPeakColor, peakFactor);\\n\\n    // --- Final Fresnel reflection blending\\n    vec3 waterColor = mix(baseColor, reflectionColor.rgb, fresnel);\\n\\n    // --- Output\\n    gl_FragColor = vec4(waterColor, uOpacity);\\n}\\n\"","import * as THREE from 'three';\nimport waterVertexShader from '../shaders/water.vert?raw';\nimport waterFragmentShader from '../shaders/water.frag?raw';\n\nexport class Water extends THREE.Mesh {\n  constructor(options = {}) {\n    super();\n\n    this.maxRipples = 10;\n    this.rippleData = [];\n\n    this.texture = new THREE.TextureLoader().load( import.meta.env.BASE_URL + \"/world-map.png\" );\n    this.texture.wrapS = THREE.RepeatWrapping;\n    this.texture.wrapT = THREE.RepeatWrapping;\n    \n\n    this.material = new THREE.ShaderMaterial({\n      vertexShader: waterVertexShader,\n      fragmentShader: waterFragmentShader,\n      uniforms: {\n        uTexture: { value: this.texture },\n        uTime: { value: 0 },\n        time: { value: 0 }, // used for ripples\n        radius: { value: options.radius },\n\n        // Wave controls\n        uWavesAmplitude: { value: 0.02 },\n        uWavesFrequency: { value: 2.0 },\n        uWavesPersistence: { value: 0.3 },\n        uWavesLacunarity: { value: 2.18 },\n        uWavesIterations: { value: 8 },\n        uWavesSpeed: { value: 0.4 },\n        \n\n        // Ripple data\n        rippleCenters: { value: Array(this.maxRipples).fill(new THREE.Vector3(0, 0, 0)) },\n        rippleStartTimes: { value: new Array(this.maxRipples).fill(0) },\n        rippleCount: { value: 0 },\n        uRippleHeight: { value: 0.01 },\n        uRippleSpeed: { value: 2.0},\n        uRippleBase: { value: 40.0},\n        uRippleFade: {value: 1.0},\n        \n\n        uGroundAmplitude: { value: 0.15 },\n\n        // Optional colors for frag shader\n        uOpacity: { value: 0.75 },\n        uEnvironmentMap: { value: options.environmentMap },\n        uTroughColor: { value: new THREE.Color('rgba(79, 158, 200, 1)') },\n        uSurfaceColor: { value: new THREE.Color('rgba(155, 216, 192, 1)') },\n        uPeakColor: { value: new THREE.Color('rgba(217, 234, 239, 1)') },\n        uWaveColor: { value: new THREE.Color('rgba(187, 216, 224, 1)') },\n        uPeakThreshold: { value: 0.01 },\n        uPeakTransition: { value: 0.05 },\n        uTroughThreshold: { value: -0.01 },\n        uTroughTransition: { value: 0.15 },\n        uFresnelScale: { value: 0.5},\n        uFresnelPower: { value: 0.02 }\n      },\n      transparent: true,\n      depthTest: true,\n      side: THREE.DoubleSide\n    });\n\n    this.geometry = new THREE.SphereGeometry(options.radius, 2048, 2048);\n  }\n\n  addRipple(positionWorld, time) {\n    const positionLocal = this.worldToLocal(positionWorld.clone());\n\n    if (this.rippleData.length >= this.maxRipples) {\n      this.rippleData.shift();\n    }\n\n    this.rippleData.push({ position: positionLocal, time });\n    this.updateRippleUniforms();\n  }\n\n  updateRippleUniforms() {\n    this.material.uniforms.rippleCount.value = this.rippleData.length;\n\n    for (let i = 0; i < this.maxRipples; i++) {\n      if (i < this.rippleData.length) {\n        this.material.uniforms.rippleCenters.value[i] = this.rippleData[i].position.clone();\n        this.material.uniforms.rippleStartTimes.value[i] = this.rippleData[i].time;\n      } else {\n        this.material.uniforms.rippleCenters.value[i] = new THREE.Vector3(0, 0, 0);\n        this.material.uniforms.rippleStartTimes.value[i] = 0;\n      }\n    }\n\n    this.material.uniforms.rippleCenters.needsUpdate = true;\n    this.material.uniforms.rippleStartTimes.needsUpdate = true;\n    this.material.uniforms.rippleCount.needsUpdate = true;\n  }\n\n  update(time) {\n    this.material.uniforms.uTime.value = time;\n    this.material.uniforms.time.value = time; // used in ripple calculation\n  }\n}\n"],"names":["waterVertexShader","waterFragmentShader","Water","THREE.Mesh","options","THREE.TextureLoader","THREE.RepeatWrapping","THREE.ShaderMaterial","THREE.Vector3","THREE.Color","THREE.DoubleSide","THREE.SphereGeometry","positionWorld","time","positionLocal","i"],"mappings":"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"}