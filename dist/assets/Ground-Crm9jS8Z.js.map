{"version":3,"file":"Ground-Crm9jS8Z.js","sources":["../../src/shaders/land.vert?raw","../../src/shaders/land.frag?raw","../../src/objects/Ground.js"],"sourcesContent":["export default \"precision highp float;\\n\\nuniform float uGroundAmplitude;\\nuniform float uGroundFrequency;\\nuniform float uGroundPersistence;\\nuniform float uGroundLacunarity;\\nuniform float uGroundIterations;\\n\\nuniform sampler2D uTexture;\\n\\nvarying vec3 vNormal;\\nvarying vec3 vWorldPosition;\\nvarying vec2 vUv; // <<< ADDED\\n\\n//\\tSimplex 2D Noise \\nvec4 permute(vec4 x) {\\n  return mod(((x * 34.0) + 1.0) * x, 289.0);\\n}\\nvec4 taylorInvSqrt(vec4 r) {\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\nvec3 permute(vec3 x) {\\n  return mod(((x * 34.0) + 1.0) * x, 289.0);\\n}\\nfloat snoise(vec2 v) {\\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439, \\n                      -0.577350269189626, 0.024390243902439);\\n  vec2 i = floor(v + dot(v, C.yy));\\n  vec2 x0 = v - i + dot(i, C.xx);\\n  vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\\n  vec4 x12 = x0.xyxy + C.xxzz;\\n  x12.xy -= i1;\\n  i = mod(i, 289.0);\\n  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) \\n                 + i.x + vec3(0.0, i1.x, 1.0));\\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\\n  m = m*m;\\n  m = m*m;\\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\\n  vec3 h = abs(x) - 0.5;\\n  vec3 ox = floor(x + 0.5);\\n  vec3 a0 = x - ox;\\n  m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\\n  vec3 g;\\n  g.x  = a0.x * x0.x + h.x * x0.y;\\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\\n  return 130.0 * dot(m, g);\\n}\\n\\n// Elevation (fBM-style noise)\\nfloat getElevation(float x, float z) {\\n  vec2 pos = vec2(x, z);\\n  float elevation = 0.0;\\n  float amplitude = 1.0;\\n  float frequency = uGroundFrequency;\\n  \\n  for (float i = 0.0; i < 10.0; i++) {\\n    if (i >= uGroundIterations) break;\\n    elevation += amplitude * snoise(pos * frequency);\\n    amplitude *= uGroundPersistence;\\n    frequency *= uGroundLacunarity;\\n  }\\n  elevation *= uGroundAmplitude;\\n  return elevation;\\n}\\n\\nfloat getElevationFromTexture(vec2 uv) {\\n    uv = 1.0 - uv;\\n\\n    vec3 texColor = texture2D(uTexture, uv).rgb;\\n    float luminance = 1.0 - texColor.r;\\n    return luminance * uGroundAmplitude;\\n}\\n\\nvoid main() {\\n  vec4 modelPosition = modelMatrix * vec4(position, 1.0);\\n\\n  vec3 sphereDir = normalize(modelPosition.xyz);\\n  // Map 3D sphere direction to 2D UV coordinates\\n  vec2 uv = vec2(\\n    0.5 + atan(sphereDir.z, sphereDir.x) / (2.0 * 3.1415926),\\n    0.5 - asin(sphereDir.y) / 3.1415926\\n  );\\n\\n  float elevation = getElevationFromTexture(uv);\\n  modelPosition.xyz += sphereDir * elevation;\\n\\n  // Pass UV to fragment shader\\n  vUv = uv; // <<< ADDED\\n\\n  float eps = 0.001;\\n  vec2 uvDx = vec2(uv.x + eps, uv.y);\\n  vec2 uvDz = vec2(uv.x, uv.y + eps);\\n  float dx = getElevationFromTexture(uvDx) - elevation;\\n  float dz = getElevationFromTexture(uvDz) - elevation;\\n  vec3 tangent = normalize(vec3(eps, dx, 0.0));\\n  vec3 bitangent = normalize(vec3(0.0, dz, eps));\\n  vec3 normal = normalize(cross(tangent, bitangent));\\n\\n  vNormal = normal;\\n  vWorldPosition = modelPosition.xyz;\\n\\n  gl_Position = projectionMatrix * viewMatrix * modelPosition;\\n  \\n}\\n\"","export default \"precision highp float;\\n\\nuniform float uTime;\\nuniform vec3 uCausticsColor;\\nuniform float uCausticsIntensity;\\nuniform float uCausticsOffset;\\nuniform float uCausticsScale;\\nuniform float uCausticsSpeed;\\nuniform float uCausticsThickness;\\nuniform float uCausticsFadeStart;\\nuniform float uCausticsFadeEnd;\\n\\nuniform float uGroundAmplitude;\\n\\nuniform float uSandScale;\\nuniform float uDuneFactor;\\n\\nuniform vec3 uSandColor1;\\nuniform vec3 uSandColor2;\\n\\nuniform sampler2D uTexture; // Needed for getElevationFromTexture()\\n\\nvarying vec3 vWorldPosition;\\nvarying vec3 vNormal;\\nvarying vec2 vUv; // <<< RECEIVED FROM VERTEX\\n\\n// Simplex 3D Noise\\nvec4 permute(vec4 x) {\\n  return mod(((x * 34.0) + 1.0) * x, 289.0);\\n}\\nvec4 taylorInvSqrt(vec4 r) {\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\nfloat snoise(vec3 v) {\\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\\n  vec3 i = floor(v + dot(v, C.yyy));\\n  vec3 x0 = v - i + dot(i, C.xxx);\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min(g.xyz, l.zxy);\\n  vec3 i2 = max(g.xyz, l.zxy);\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\\n  vec3 x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  i = mod(i, 289.0);\\n  vec4 p = permute(\\n    permute(\\n      permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) +\\n      i.y + vec4(0.0, i1.y, i2.y, 1.0)\\n    ) +\\n    i.x + vec4(0.0, i1.x, i2.x, 1.0)\\n  );\\n  float n_ = 1.0 / 7.0;\\n  vec3 ns = n_ * D.wyz - D.xzx;\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_);\\n  vec4 x = x_ * ns.x + ns.yyyy;\\n  vec4 y = y_ * ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n  vec4 b0 = vec4(x.xy, y.xy);\\n  vec4 b1 = vec4(x.zw, y.zw);\\n  vec4 s0 = floor(b0) * 2.0 + 1.0;\\n  vec4 s1 = floor(b1) * 2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\\n  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\\n  vec3 p0 = vec3(a0.xy, h.x);\\n  vec3 p1 = vec3(a0.zw, h.y);\\n  vec3 p2 = vec3(a1.xy, h.z);\\n  vec3 p3 = vec3(a1.zw, h.w);\\n  vec4 norm = taylorInvSqrt(\\n    vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3))\\n  );\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n  vec4 m = max(\\n    0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)),\\n    0.0\\n  );\\n  m = m * m;\\n  return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),\\n                                dot(p2, x2), dot(p3, x3)));\\n}\\n\\n// Use texture to get elevation\\nfloat getElevationFromTexture(vec2 uv) {\\n    uv = 1.0 - uv;\\n\\n    vec3 texColor = texture2D(uTexture, uv).rgb;\\n    float luminance = 1.0 - texColor.r;\\n    return luminance * uGroundAmplitude;\\n}\\n\\nvoid main() {\\n  vec3 normalizedPos = normalize(vWorldPosition);\\n\\n  // Animated caustics using 3D noise directly\\n  vec3 causticsPos = vWorldPosition * uCausticsScale + uTime * uCausticsSpeed;\\n  float causticsVal = snoise(causticsPos);\\n  causticsVal = uCausticsOffset - abs(causticsVal);\\n  \\n  // Get elevation from texture\\n  float elevation = getElevationFromTexture(vUv);\\n\\n  // Fade factor based on elevation\\n  float fade = 1.0 - smoothstep(uCausticsFadeStart, uCausticsFadeEnd, elevation);\\n\\n  // Caustics strength including elevation fade\\n  float caustics = smoothstep(0.5 - uCausticsThickness, 0.5 + uCausticsThickness, causticsVal) \\n                * uCausticsIntensity \\n                * fade;\\n\\n                \\n  // Static sand pattern tied to position and time\\n  float n = snoise(normalizedPos * uSandScale + uTime * 0.1);\\n  vec3 baseSand = mix(uSandColor1, uSandColor2, n * 0.5 + 0.5);\\n\\n  // Simple dune shading\\n  float duneShade = 0.5 + 0.5 * uDuneFactor;\\n  vec3 baseColor = baseSand * (0.9 + 0.1 * duneShade);\\n\\n\\n  vec3 finalColor = baseColor + caustics * uCausticsColor;\\n\\n  gl_FragColor = vec4(finalColor, 1.0);\\n}\\n\"","import * as THREE from 'three';\nimport landVertexShader from '../shaders/land.vert?raw';\nimport landFragmentShader from '../shaders/land.frag?raw';\n\nexport class Ground extends THREE.Mesh {\n  constructor(options = {}) {\n    super();\n       \n    this.texture = new THREE.TextureLoader().load( import.meta.env.BASE_URL+ \"/world-map.png\" );\n    this.texture.wrapS = THREE.RepeatWrapping;\n    this.texture.wrapT = THREE.RepeatWrapping;\n    \n    this.material = new THREE.ShaderMaterial({\n      vertexShader: landVertexShader,\n      fragmentShader: landFragmentShader,\n      uniforms: {\n        uTexture: { value: options.texture },\n        uTime: { value: 0 },\n        uCausticsColor: { value: new THREE.Color('#ffffff') },\n        uCausticsIntensity: { value: 0.1 },\n        uCausticsScale: { value: 8.0 },\n        uCausticsSpeed: { value: 1.0 },\n        uCausticsThickness: { value: 0.4 },\n        uCausticsOffset: { value: 0.75 },\n        uCausticsFadeStart: { value: 0.0 },\n        uCausticsFadeEnd: { value: 0.10 },\n        uSandScale: { value: 200.0 },\n        \n        uTexture: { value: this.texture },\n\n\n        uDuneFactor : { value: 1.0},\n        uGroundAmplitude: { value: 0.15 },\n        uGroundFrequency: { value: 1.07 },\n        uGroundPersistence: { value: 0.3 },\n        uGroundLacunarity: { value: 2.18 },\n        uGroundIterations: { value: 8 },\n\n        uSandColor1: { value: new THREE.Color('rgba(243, 224, 181, 1)') },\n        uSandColor2: { value: new THREE.Color('rgba(252, 237, 209, 1)') }\n      }\n    });\n\n\n    this.geometry = new THREE.SphereGeometry(options.radius*0.95, 2048, 2048);\n  }\n\n  update(time) {\n    this.material.uniforms.uTime.value = time;\n  }\n} "],"names":["landVertexShader","landFragmentShader","Ground","THREE.Mesh","options","THREE.TextureLoader","THREE.RepeatWrapping","THREE.ShaderMaterial","THREE.Color","THREE.SphereGeometry","time"],"mappings":"kFAAA,MAAeA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAAC,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECIF,MAAAC,UAAeC,CAAW,CACrC,YAAYC,EAAU,GAAI,CAClB,MAAA,EAEN,KAAK,QAAU,IAAIC,EAAoB,EAAE,KAAM,yBAA2C,EACrF,KAAA,QAAQ,MAAQC,EAChB,KAAA,QAAQ,MAAQA,EAEhB,KAAA,SAAW,IAAIC,EAAqB,CACvC,aAAcP,EACd,eAAgBC,EAChB,SAAU,CACR,SAAU,CAAE,MAAOG,EAAQ,OAAQ,EACnC,MAAO,CAAE,MAAO,CAAE,EAClB,eAAgB,CAAE,MAAO,IAAII,EAAY,SAAS,CAAE,EACpD,mBAAoB,CAAE,MAAO,EAAI,EACjC,eAAgB,CAAE,MAAO,CAAI,EAC7B,eAAgB,CAAE,MAAO,CAAI,EAC7B,mBAAoB,CAAE,MAAO,EAAI,EACjC,gBAAiB,CAAE,MAAO,GAAK,EAC/B,mBAAoB,CAAE,MAAO,CAAI,EACjC,iBAAkB,CAAE,MAAO,EAAK,EAChC,WAAY,CAAE,MAAO,GAAM,EAE3B,SAAU,CAAE,MAAO,KAAK,OAAQ,EAGhC,YAAc,CAAE,MAAO,CAAG,EAC1B,iBAAkB,CAAE,MAAO,GAAK,EAChC,iBAAkB,CAAE,MAAO,IAAK,EAChC,mBAAoB,CAAE,MAAO,EAAI,EACjC,kBAAmB,CAAE,MAAO,IAAK,EACjC,kBAAmB,CAAE,MAAO,CAAE,EAE9B,YAAa,CAAE,MAAO,IAAIA,EAAY,wBAAwB,CAAE,EAChE,YAAa,CAAE,MAAO,IAAIA,EAAY,wBAAwB,CAAE,CAAA,CAClE,CACD,EAGI,KAAA,SAAW,IAAIC,EAAqBL,EAAQ,OAAO,IAAM,KAAM,IAAI,CAAA,CAG1E,OAAOM,EAAM,CACN,KAAA,SAAS,SAAS,MAAM,MAAQA,CAAA,CAEzC"}